
""" 
=========================================================================
This file is part of LyX Notebook, which works with LyX but is an 
independent project.  License details (MIT) can be found in the file 
COPYING.

Copyright (c) 2012 Allen Barker
=========================================================================

This module provides the class ExternalInterpreter, which runs an external
interpreter and passes strings back and forth to it.  It uses a pseudo-tty to
run the specified interpreter interactively.

Some of this code is based on an example from
http://stackoverflow.com/questions/4022600/python-pty-fork-how-does-it-work

Note that the Python interpreter's output can be redirected to a file, as
   python >outfile
which only echos the input but sends all output to the file.
Redirecting stderr, output 2, sends the Python prompts to a different file
   python >outfile 2>startupMessageAndPrompts
Maybe modify later to use a separate file, to avoid problems if a program
writes a prompt to output.

With scala,
   scala >outfile
*everything* goes into outfile, including echo of typed stuff.

"""

from __future__ import print_function, division
import sys, os, time, pty, signal
# import subprocess # for alternative where subprocess.call is used
import interpreterSpecs # only needed for testing code at end


class ExternalInterpreter(object):
   """This class runs a single external interpreter.  There can be multiple
   instances, each running a possibly different interpreter application.
   The interpreter is forked as a process connected to a pseudo-tty, so
   applications which expect terminal input can be run.  The only initialization
   argument is an interpreterSpec dict object which has the predefined collection 
   of keys all defined."""

   def __init__(self, interpreterSpec):
      self.debug = False # debug flag, for verbose output
      # copy some of interpreterSpec data which is used in this
      # module to class member variables
      self.progName = interpreterSpec["progName"]
      self.insetSpecifier = interpreterSpec["insetSpecifier"]
      self.mainPrompt = interpreterSpec["mainPrompt"]
      self.contPrompt = interpreterSpec["contPrompt"]
      self.runCommand = interpreterSpec["runCommand"]
      self.runArguments = interpreterSpec["runArguments"]
      self.startupSleepSecs = interpreterSpec["startupSleepSecs"]
      self.beforeReadSleepSecs = interpreterSpec["beforeReadSleepSecs"]
      self.exitCommand = interpreterSpec["exitCommand"]

      self.running = False
      self.beforeFirstRead = True
      self.beforeFirstReadOrWrite = True
      self.readErrorFound = False
      if self.debug: print("running", self.progName)

      # try a pseudo-terminal fork
      try:
         # self.child_pid     is the child's PID
         # self.fd            is a Unix file number (not a Python handle) for pty
         # Note that fd acts as both stdin and stdout for the child process.
         (self.child_pid, self.fd) = pty.fork()
         # child_pid, fd = os.forkpty()    # OK (from original example, not tested)
      except OSError as e:
         print(str(e))
    
      # Note: unlike OS fork; in pty fork we MUST use the fd variable
      # somewhere (i.e. in parent process; it does not exist for child)
      # ... actually, we must READ from fd in parent process...
      # if we don't - child process will never be spawned!
    
      #
      # Child process handling code.
      #
      if self.child_pid == 0: # in child process
         # Warning: Errors generated by the child are not sent to the
         # usual stderr, and so it can appear to silently fail!
         # All print statements to stdout in child go to the pseudo-tty fd.

         # Note that child's fd is invalid (equal to -1); cannot write to it.
         if self.debug: print("   Child after pty.fork, fd is", self.fd,
               "and child_pid is", self.child_pid)

         # Note that child's print to stdout goes to the self.fd pseudo-tty file.
         # The write/print line below is necessary: it provides something for the 
         # parent process to read to cause the child to be spawned.
         #print "In Child Process: PID# %s" % os.getpid()
         #print "In Child Process: PID=" + str(os.getpid())
         sys.stdout.write("   In Child Process: PID=" + str(os.getpid()) + "\n")
         sys.stdout.flush()
    
         # Run os.execlp to replace the child process with the program to run.
         # The arguments to os.execlp are:
         #    first, the executable of the command to be run (in the OS)
         #    second, a name of the executable for the process list ("ps axf")
         #    third and successive arguments are passed to the command as arguments
         # Example:
         #    os.execlp("python","ThePythonProgram", "-u", "pyecho.py")
         try:
            os.execlp(self.runCommand, "LyxNotebook"+self.insetSpecifier+"Process",
                  *self.runArguments)
            # below line also works in place of above (with exit below and import)
            #subprocess.call([self.runCommand]+self.runArguments, shell=True)
         except:
            print("Cannot spawn execlp...")
         # sys.exit(0) # needed when subprocess.call is used above
      #
      # Parent process handling code.
      #
      else: # in parent process
         if self.debug: print("Parent after pty.fork, fd is", self.fd,
               "and child_pid is", self.child_pid)
         # This print below is not strictly necessary, but matches the one in child.
         if self.debug: print("In Parent Process: PID=" + str(os.getpid()))
         # We MUST read from fd in order for the child to be spawned.
         try:
            firstReadFromFd = os.read(self.fd, 10000)
         except OSError:
            self.reportReadError()
            return
         if self.debug: print(firstReadFromFd)
         # This ^^ line above prints out the "In Child Process..." string written
         # by the child process.
         self.spawnTime = time.time()
         
         # self.readInterpreterInitMessage() # wait and do this on-demand (read/write)
      return
         
   def readInterpreterInitMessage(self):
      """Read the initialization message from the interpreter, and the first
      prompt (after waiting at least self.startupSleepSecs since self.spawnTime).
      This is an internal initialization routine."""
      time.sleep(max([0, (self.spawnTime + self.startupSleepSecs) - time.time()]))
      #self.interpreterList[i].write("x=5\n")
      #self.interpreterList[i].write("print x*x\n")
      print("----- initialization message of interpreter", self.progName)
      print(self.read())
      print("----- end initialization of interpreter", self.progName)

   def write(self, string):
      """Writes to the stdin of the child's process.  The input string should be 
      code that is executable in the interpreter, and should be newline terminated."""
      if self.beforeFirstReadOrWrite:
         # time.sleep(self.startupSleepSecs)
         self.beforeFirstReadOrWrite = False
         self.readInterpreterInitMessage()
      # write string to fd, returns # bytes
      stringByteArray = string.encode("utf-8") # encode for Python3 compatibility
      numBytesWritten = os.write(self.fd,stringByteArray)
      sys.stdout.flush()
      # Before the first self.read we must read back the writes, or they will
      # produce a double echo effect... just how it works.  We don't need this
      # when readInterpreterInitMessage() always reads before a write, but it is
      # good to handle in general.
      if self.beforeFirstRead and not self.readErrorFound:
         # sys.stdout.flush()
         try:
            os.read(self.fd,100000)
         except OSError:
            self.reportReadError()

   def read(self, maxBytes=100000, removeBackslashR = True):
      """Reads from the stdout of the child process, up until a new prompt appears.
      The process is read until a prompt on a new line is detected.
      The directly read strings have newlines of \\r\\n, but by default the \\r 
      values are removed before returning the final string value (since it can 
      cause problems in later processing)."""
      if self.beforeFirstReadOrWrite: 
         # time.sleep(self.startupSleepSecs)
         self.beforeFirstReadOrWrite = False
         self.readInterpreterInitMessage()
      readString = ""
      while True:
         # brief sleep to make sure child has time to read any writes into its stdin
         time.sleep(self.beforeReadSleepSecs) 
         sys.stdout.flush()
         sys.stdin.flush() # probably not be needed
         # read at most maxBytes bytes from fd, return "" at EOF
         try:
            readString += os.read(self.fd, maxBytes).decode("utf-8") # decode for Python3
         except OSError:
            self.reportReadError()
         if self.readErrorFound:
            # return nothing for now, user must see message on screen
            self.reportReadError() # print message again
            errString = u"\nError in LyxNotebook reading interpreter, see error" \
                         " messages.\n"
            errString += self.mainPrompt # add prompt so string appears in output
            return errString
         
         # We read until the interpreter returns a prompt, so we know that it is
         # finished with its evaluation.  
         
         # TODO: This can cause an error if
         # the code prints a newline followed by a prompt and then goes into
         # a calculation causing it to hang for a while.  Not likely, but worth
         # noting and considering.  If so, could reset prompt to an even less 
         # likely string, or for some interpreters could redirect the prompt
         # strings to a named pipe to read from.  Or just "don't do that."
         # 
         # Note this Python test case fails as expected.
         # def hang():
         #    print "\n>>> "
         #    time.sleep(4)
         #    print "not printed"
         # hang()

         lines = readString.splitlines()  # keepends = False
         possibleMainPrompt = lines[-1]
         possibleContPrompt = lines[-1]

         # see if we really got a prompt...
         # note that some interpreters will add autoindent spaces, so look for prefix
         if (possibleMainPrompt.find(self.mainPrompt) == 0 
               and possibleMainPrompt.rstrip() == self.mainPrompt.rstrip()): 
            if self.debug: print("got a main prompt, breaking")
            break
         if (possibleContPrompt.find(self.contPrompt) == 0 
               and possibleContPrompt.rstrip() == self.contPrompt.rstrip()): 
            if self.debug: print("got a continuation prompt, breaking")
            break
         # This sleep only executes waiting for slow operations on the child to  
         # return a prompt, or when there is some problem causing a hang
         time.sleep(0.5) # could sum up to get a maxTime for possible hangs, throw err
      if removeBackslashR:
         # assume no naturally occurring \r characters and only " \r" or "\r\n"
         readString = readString.replace("\r\n","\n")
         # very long lines sent to intrpreter can have " \r" inserted in result...
         readString = readString.replace(" \r","")
         # now delete any remaining \r characters
         readString = readString.replace("\r","")
      self.beforeFirstRead = False
      return readString

   def kill(self, soft=True, hard=False):
      """Do a soft or a hard kill, or both to try soft before hard."""
      # controlD = "\x04"
      if soft:
         exitSequence = self.exitCommand.splitlines(True) # keepends=True
         for command in exitSequence:
            self.write(command)
         if hard: time.sleep(1) # wait one second for soft kill before trying hard
      if hard:
         os.kill(self.child_pid,signal.SIGKILL)
      os.waitpid(self.child_pid, 0)
      os.close(self.fd)
      self.running = False
      return

   def __del__(self):
      if self.running:
         self.kill(True, True)
      return

   def reportReadError(self):
      self.readErrorFound = True
      print("Error in LyxNotebook reading the output from interpreter"
            "\nstarted with this command string:\n   ", self.runCommand,
            "\nNo output can be read.  Are you sure the path to the"
            "\ninterpreter's executable is correct?", file=sys.stderr)
      return

#
# ====================== module tests =========================================
#

if __name__ == "__main__":

   print("--------------- starting tests of externalInterpreter ONLY -----")
   interp = ExternalInterpreter(interpreterSpecs.python)
   #interp = ExternalInterpreter(interpreterSpecs.sage)
   print("created new external class")

   interp.write("x=5\n")
   interp.write("print x*x\n")
   print(interp.read())

   #sys.exit(0)

   inChars = ""
   interp.write("x=5\n")
   inChars += interp.read()
   #sys.stdout.write(inChars); inChars=""
   # Note extra \n required in line below, since raw writes are being used (not
   # the fancy version that sends newline on indentation down to zero) and we
   # will get a continuation prompt if only a single \n is sent.
   interp.write("if 4!=3: pass\n\n")  
   inChars += interp.read()
   sys.stdout.write(inChars); inChars=""

   interp.write("print 'extra bonus 1'\n")
   # inChars += interp.read()
   interp.write("print 'extra bonus 2'\n")
   #inChars += interp.read()
   interp.write("print 'extra bonus 3'\n")
   inChars += interp.read()
   sys.stdout.write(inChars); inChars=""
   #print()
   #print("done first batch")

   interp.write("for i in range(0,10000): w=i+1\n\n") # note extra \n required!
   inChars += interp.read() # if we read right after, avoid the piling-up double echo
   """ 
   If our controller process goes on and writes later lines while python churns 
   on loop we can get the "piling up" effect, where stdin doesn't get read soon
   enough by the child process and so the parent reads it back, causing double echo
   (caused by child sharing stdin and stdout on a single file descriptor fd).
   This suggests that we should do a read after *each* line, really line by line
   We don't want the writer to get ahead of the child's stdin reader.
   """
   interp.write("print 'extra bonus 4'\n")
   interp.write("x=5\n")
   interp.write("x\n")
   interp.write("print 'extra bonus 5'\n")
   inChars += interp.read()
   sys.stdout.write(inChars); inChars=""
   #print()
   #print("done second batch")
   print("before soft kill")
   # interp.kill(soft=True, hard=True)
   print("after soft kill")
   interp.write("print 'this will be an error if kill above is uncommented'\n")
   print(interp.read())

   
