# -*- coding: utf-8 -*-
"""
=========================================================================
This file is part of LyX Notebook, which works with LyX but is an
independent project.  License details (MIT) can be found in the file
COPYING.

Copyright (c) 2012 Allen Barker
=========================================================================

This module provides the class `ExternalInterpreter`, which runs an external
interpreter and passes strings back and forth to it.  It uses a pseudo-tty to
run the specified interpreter interactively.  It works similarly to the Pexpect
program (that program might replace some parts at some point, but it works as
is).

Some of this code is based on an example from
http://stackoverflow.com/questions/4022600/python-pty-fork-how-does-it-work

Note that the Python interpreter's output can be redirected to a file, as::
   python >outfile
which only echos the input but sends all output to the file.

Redirecting stderr, output 2, sends the Python prompts to a different file::
   python >outfile 2>startupMessageAndPrompts

Maybe modify later to use a separate file, to avoid problems if a program
writes a prompt to output.

With scala::
   scala >outfile
*everything* goes into outfile, including echo of typed stuff.

"""

from __future__ import print_function, division
import sys
import os
import time
import pty
import signal
# import subprocess # for alternative where subprocess.call is used
import interpreter_specs # only needed for testing code at end


class ExternalInterpreter(object):
    """This class runs a single external interpreter.  There can be multiple
    instances, each running a possibly different interpreter application.  The
    interpreter is forked as a process connected to a pseudo-tty, so
    applications which expect terminal input can be run.  The only
    initialization argument is an interpreterSpec dict object which has the
    predefined collection of keys all defined."""

    def __init__(self, interpreterSpec):
        self.debug = False # debug flag, for verbose output
        # copy some of interpreterSpec data which is used in this
        # module to class member variables
        self.progName = interpreterSpec["progName"]
        self.insetSpecifier = interpreterSpec["insetSpecifier"]
        self.mainPrompt = interpreterSpec["mainPrompt"]
        self.contPrompt = interpreterSpec["contPrompt"]
        self.runCommand = interpreterSpec["runCommand"]
        self.runArguments = interpreterSpec["runArguments"]
        self.startupSleepSecs = interpreterSpec["startupSleepSecs"]
        self.beforeReadSleepSecs = interpreterSpec["beforeReadSleepSecs"]
        self.exitCommand = interpreterSpec["exitCommand"]

        self.running = False
        self.beforeFirstRead = True
        self.beforeFirstReadOrWrite = True
        self.readErrorFound = False
        if self.debug: print("running", self.progName)

        # try a pseudo-terminal fork
        try:
            # self.child_pid     is the child's PID
            # self.fd            is a Unix file number (not a Python handle) for pty
            # Note that fd acts as both stdin and stdout for the child process.
            self.child_pid, self.fd = pty.fork()
            # child_pid, fd = os.forkpty()    # OK (from original example, not tested)
        except OSError as e:
            print(str(e))

        # Note: unlike OS fork; in pty fork we MUST use the fd variable
        # somewhere (i.e. in parent process; it does not exist for child)
        # ... actually, we must READ from fd in parent process...
        # if we don't - child process will never be spawned!

        #
        # Child process handling code.
        #
        if self.child_pid == 0: # in child process
            # Warning: Errors generated by the child are not sent to the
            # usual stderr, and so it can appear to silently fail!
            # All print statements to stdout in child go to the pseudo-tty fd.

            # Note that child's fd is invalid (equal to -1); cannot write to it.
            if self.debug: print("   Child after pty.fork, fd is", self.fd,
                                 "and child_pid is", self.child_pid)

            # Note that child's print to stdout goes to the self.fd pseudo-tty file.
            # The write/print line below is necessary: it provides something for the
            # parent process to read to cause the child to be spawned.
            #print "In Child Process: PID# %s" % os.getpid()
            #print "In Child Process: PID=" + str(os.getpid())
            sys.stdout.write("   In Child Process: PID=" + str(os.getpid()) + "\n")
            sys.stdout.flush()

            # Run os.execlp to replace the child process with the program to run.
            # The arguments to os.execlp are:
            #    first, the executable of the command to be run (in the OS)
            #    second, a name of the executable for the process list ("ps axf")
            #    third and successive arguments are passed to the command as arguments
            # Example:
            #    os.execlp("python","ThePythonProgram", "-u", "pyecho.py")
            try:
                os.execlp(self.runCommand, "LyxNotebook"+self.insetSpecifier+"Process",
                          *self.runArguments)
                # below line also works in place of above (with exit below and import)
                #subprocess.call([self.runCommand]+self.runArguments, shell=True)
            except:
                print("Cannot spawn execlp...")
            # sys.exit(0) # needed when subprocess.call is used above
        #
        # Parent process handling code.
        #
        else: # in parent process
            if self.debug: print("Parent after pty.fork, fd is", self.fd,
                                 "and child_pid is", self.child_pid)
            # This print below is not strictly necessary, but matches the one in child.
            if self.debug: print("In Parent Process: PID=" + str(os.getpid()))
            # We MUST read from fd in order for the child to be spawned.
            try:
                firstReadFromFd = os.read(self.fd, 10000)
            except OSError:
                self.reportReadError()
                return
            if self.debug: print(firstReadFromFd)
            # This ^^ line above prints out the "In Child Process..." string written
            # by the child process.
            self.spawnTime = time.time()

            # self.readInterpreterInitMessage() # wait and do this on-demand (read/write)
        return

    def readInterpreterInitMessage(self):
        """Read the initialization message from the interpreter, and the first
        prompt (after waiting at least self.startupSleepSecs since self.spawnTime).
        This is an internal initialization routine."""
        time.sleep(max([0, (self.spawnTime + self.startupSleepSecs) - time.time()]))
        #self.interpreterList[i].write("x=5\n")
        #self.interpreterList[i].write("print x*x\n")
        print("----- initialization message of interpreter", self.progName)
        print(self.read())
        print("----- end initialization of interpreter", self.progName)

    def write(self, string):
        """Writes to the stdin of the child's process.  The input string should be
        code that is executable in the interpreter, and should be newline terminated."""
        if self.beforeFirstReadOrWrite:
            # time.sleep(self.startupSleepSecs)
            self.beforeFirstReadOrWrite = False
            self.readInterpreterInitMessage()
        # write string to fd, returns # bytes
        stringByteArray = string.encode("utf-8") # encode for Python3 compatibility
        numBytesWritten = os.write(self.fd, stringByteArray) # return val currently unused
        sys.stdout.flush()
        # Before the first self.read we must read back the writes, or they will
        # produce a double echo effect... just how it works.  We don't need this
        # when readInterpreterInitMessage() always reads before a write, but it is
        # good to handle in general.
        if self.beforeFirstRead and not self.readErrorFound:
            # sys.stdout.flush()
            try:
                os.read(self.fd, 100000)
            except OSError:
                self.reportReadError()

    def read(self, maxBytes=100000, removeBackslashR=True):
        """Reads from the stdout of the child process, up until a new prompt appears.
        The process is read until a prompt on a new line is detected.
        The directly read strings have newlines of \\r\\n, but by default the \\r
        values are removed before returning the final string value (since it can
        cause problems in later processing)."""
        if self.beforeFirstReadOrWrite:
            # time.sleep(self.startupSleepSecs)
            self.beforeFirstReadOrWrite = False
            self.readInterpreterInitMessage()
        readString = ""
        while True:
            # brief sleep to make sure child has time to read any writes into its stdin
            time.sleep(self.beforeReadSleepSecs)
            sys.stdout.flush()
            sys.stdin.flush() # probably not be needed
            # read at most maxBytes bytes from fd, return "" at EOF
            try:
                readString += os.read(self.fd, maxBytes).decode(
                    "utf-8") # decode for Python3
            except OSError:
                self.reportReadError()
            if self.readErrorFound:
                # return nothing for now, user must see message on screen
                self.reportReadError() # print message again
                errString = u"\nError in LyxNotebook reading interpreter, see error" \
                    " messages.\n"
                errString += self.mainPrompt # add prompt so string appears in output
                return errString

            # We read until the interpreter returns a prompt, so we know that it is
            # finished with its evaluation.

            # TODO: This can cause an error if
            # the code prints a newline followed by a prompt and then goes into
            # a calculation causing it to hang for a while.  Not likely, but worth
            # noting and considering.  If so, could reset prompt to an even less
            # likely string, or for some interpreters could redirect the prompt
            # strings to a named pipe to read from.  Or just "don't do that."
            #
            # Note this Python test case fails as expected.
            # def hang():
            #    print "\n>>> "
            #    time.sleep(4)
            #    print "not printed"
            # hang()

            lines = readString.splitlines()  # keepends = False
            possibleMainPrompt = lines[-1]
            possibleContPrompt = lines[-1]

            # see if we really got a prompt...
            # note that some interpreters will add autoindent spaces, so look for prefix
            if (possibleMainPrompt.find(self.mainPrompt) == 0
                             and possibleMainPrompt.rstrip() == self.mainPrompt.rstrip()):
                if self.debug: print("got a main prompt, breaking")
                break
            if (possibleContPrompt.find(self.contPrompt) == 0
                             and possibleContPrompt.rstrip() == self.contPrompt.rstrip()):
                if self.debug: print("got a continuation prompt, breaking")
                break
            # This sleep only executes waiting for slow operations on the child to
            # return a prompt, or when there is some problem causing a hang
            time.sleep(0.5) # could sum up to get a maxTime for possible hangs, throw err
        if removeBackslashR:
            # assume no naturally occurring \r characters and only " \r" or "\r\n"
            readString = readString.replace("\r\n", "\n")
            # very long lines sent to intrpreter can have " \r" inserted in result...
            readString = readString.replace(" \r", "")
            # now delete any remaining \r characters
            readString = readString.replace("\r", "")
        self.beforeFirstRead = False
        return readString

    def kill(self, soft=True, hard=False):
        """Do a soft or a hard kill, or both to try soft before hard."""
        # controlD = "\x04"
        if soft:
            exitSequence = self.exitCommand.splitlines(True) # keepends=True
            for command in exitSequence:
                self.write(command)
            if hard: time.sleep(1) # wait one second for soft kill before trying hard
        if hard:
            os.kill(self.child_pid, signal.SIGKILL)
        os.waitpid(self.child_pid, 0)
        os.close(self.fd)
        self.running = False
        return

    def __del__(self):
        if self.running:
            self.kill(True, True)
        return

    def reportReadError(self):
        self.readErrorFound = True
        print("Error in LyxNotebook reading the output from interpreter"
              "\nstarted with this command string:\n   ", self.runCommand,
              "\nNo output can be read.  Are you sure the path to the"
              "\ninterpreter's executable is correct?", file=sys.stderr)
        return

#
# ====================== module tests =========================================
#

if __name__ == "__main__":

    print("--------------- starting tests of external_interpreter ONLY -----")
    interp = ExternalInterpreter(interpreter_specs.python)
    #interp = ExternalInterpreter(interpreter_specs.sage)
    print("created new external class")

    interp.write("x=5\n")
    interp.write("print x*x\n")
    print(interp.read())

    #sys.exit(0)

    inChars = ""
    interp.write("x=5\n")
    inChars += interp.read()
    #sys.stdout.write(inChars); inChars=""
    # Note extra \n required in line below, since raw writes are being used (not
    # the fancy version that sends newline on indentation down to zero) and we
    # will get a continuation prompt if only a single \n is sent.
    interp.write("if 4!=3: pass\n\n")
    inChars += interp.read()
    sys.stdout.write(inChars); inChars = ""

    interp.write("print 'extra bonus 1'\n")
    # inChars += interp.read()
    interp.write("print 'extra bonus 2'\n")
    #inChars += interp.read()
    interp.write("print 'extra bonus 3'\n")
    inChars += interp.read()
    sys.stdout.write(inChars); inChars = ""
    #print()
    #print("done first batch")

    interp.write("for i in range(0,10000): w=i+1\n\n") # note extra \n required!
    inChars += interp.read() # if we read right after, avoid the piling-up double echo
    """
   If our controller process goes on and writes later lines while python churns
   on loop we can get the "piling up" effect, where stdin doesn't get read soon
   enough by the child process and so the parent reads it back, causing double echo
   (caused by child sharing stdin and stdout on a single file descriptor fd).
   This suggests that we should do a read after *each* line, really line by line
   We don't want the writer to get ahead of the child's stdin reader.
   """
    interp.write("print 'extra bonus 4'\n")
    interp.write("x=5\n")
    interp.write("x\n")
    interp.write("print 'extra bonus 5'\n")
    inChars += interp.read()
    sys.stdout.write(inChars); inChars = ""
    #print()
    #print("done second batch")
    print("before soft kill")
    # interp.kill(soft=True, hard=True)
    print("after soft kill")
    interp.write("print 'this will be an error if kill above is uncommented'\n")
    print(interp.read())
